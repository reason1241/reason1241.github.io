---
layout: post
title:  "토비 스프링 2장"
date:   2019-02-06 22:00:00
categories: Tech
---
# 2장 테스트


## 1. UserDaoTest 다시보기
  - 스프링의 "객체지향"과 "테스트"가 중요.
  - 웹을 통해 테스트를 하는 방법은 모든 기능을 다 만든 후에 할 수 있으며, 문제 발생시 문제 발생의 원인을 찾기 힘듦. 
  - 테스트는 가능한 작은 단위로 쪼개서 하는 것이 좋음.(관심사의 분리) -> 단위 테스트
  - 단위 테스트는 외부 상태에 의존하지 않아야 함.
  - 이를 사람이 직접하기는 번거로움 -> 자동수행 테스트 코드의 작성.
  - 클래스의 분리 등으로 main에 테스트 코드 넣기가 애매 -> Test관련 Class를 별도로 만듦.
  ### 하지만..
  - 확인 작업을 수동으로 하는 것은 번거로움.
  - 실행 작업또한 수동으로 하는 것은 번거로움.

## 2. UserDaoTest 개선
  ### 테스트 검증의 자동화
    - 테스트는 성공과 실패로 구분. -> 실패는 또 에러로 인한 테스트 에러, 결과가 예상 외로 낭는 테스트 실패로 구분.
    - add()는 전달기능이며 에러 발생 없을 시 성공으로 간주.
    - get()은 가져오기 기능, get()을 통해 add() 또한 검증.
    - 만들어진 코드의 기능을 모두 점검할 수 있는 포괄적인 테스트(comprehensive test)로 코드 변화 후의 안정성 확보.
    
  ### 테스트의 효율적인 수행과 결과 관리
    - JUnit(프레임워크)을 이용해 테스트를 하자!
    - 기존의 main()메소드 테스트를 일반 메소드로 옮긴다.
    - 이 경우, 메소드는 public으로 선언 되어야 하며, @Test Annotation을 붙여야함.
    - if else 문 대신 assertThat이라는 스태틱 메소드를 이용.
    - ex) assertThat(user2.getName(), is(user.getName());
    - main()안에서 JUit을 실행시켜야 함.
## 3. 개발자를 위한 테스팅 프레임워크 JUnit
  ### JUnit 테스트 실행 방법
    - 이정도는 알아서 하시라
  ### 테스트 결과의 일관성
    - 지금까지는 DB에 add() 실행 후 데이터를 직접 지워주어야 했음.
    - 지우는 기능을 추가해서 테스트 후 삭제를 하고, 몇개의 레코드가 있는지도 세서 알려주자.
  ### 포괄적인 테스트
    - @Test는 순서대로 실행되지 않음. 순서에 영향을 받는 테스트는 실패한 테스트.
    - 문제의 발생에 대한 Exception을 정의하여 이용.
    - 스프링에는 미리 정의된 데이터 엑세스 예외 클래스들이 존재.. EmptyResultDataAccessException 등..
    - 예외 발생이 예상되는 테스트는 @Test(expected=EmptyResultDataAccessException.class)와 같이 정의 가능.
    - 정상적인 케이스만 테스트하면 안됨 -> 테스트 작성 시 부정적인 케이스 먼저 만드는 것이 좋음.
  ### 테스트가 이끄는 개발(TDD)
    - given(조건) -> when(행위) -> then(결과)
    - 한번에 많은 코드를 만들고 테스트를 돌리는 것은 좋지 않음. -> 짧게 짧게 가는 것이 좋음.
  ### 테스트 코드 개선
    - 테스트 코드 또한 리팩토링을 하는 것이 좋음.
    - Test전에 반복되는 작업은 @Before에, Test후에 반복되는 작업은 @After에 넣어줌.
    - JUnit의 테스트 수행 방식
      1. @Test가 붙은 public void의 테스트 메소드를 찾음.
      2. 테스트 클래스의 오브젝트를 만듦.
      3. @Before를 실행.
      4. @Test 하나 실행, 테스트 결과 저장.
      5. @After 실행.
      6. 2~5의 반복.
      7. 테스트 결과의 종합.
    - @Before 등에서는 인스턴스 변수를 이용해야 함.
    - 각 테스트 메소드를 실행할 떄마다 테스트 클래스의 오브젝트를 새로 만듦.
    - 일부 테스트 메소드에서만 이용하는 코드는 일반적인 메소드 추출 방법을 쓰는 편이 나음.
    - Fixture : 테스트 수행에 필요한 정보나 오브젝트.
## 4. 스프링 테스트 적용
  - @Before 메소드가 테스트 메소드 개수만큼 반복 -> AC 생성에 적지 않은 시간이 걸릴수도..
  - AC생성 시에는 싱글톤 빈 오브젝트를 모두 초기화.. -> 어떤 빈은 오브젝트 생성시 자체적인 초기화 작업을 진행 -> 시간 많이 필요.
  - AC생성 시 어떤 빈은 독자적으로 많은 리소스를 할당하거나 독립적인 스레드를 띄움.
  - 테스트를 마칠 때마다 AC 내의 빈이 할당한 리소스 등을 깔끔하게 정리하지 않으면 다음 테스트 시 새 AC가 만들어지며 문제 발생 가능성.
  - AC는 여러 테스트가 공유해서 써도 됨. -> JUnit이 테스트 클래스의 오브젝트를 매번 새로 만듦. -> @BeforeClass는 테스트 클래스 전체에 걸쳐 한번만 실행.
  ### 테스트를 위한 애플리케이션 컨텍스트 관리
    - AC를 인스턴스 변수로 선언 후 @Autowired를 이용해 AC를 만들어 할당 해주며, @RunWith, @ContextConfiguration을 붙여줌.
    - @RunWith -> JUnit프레임워크의 테스트 실행 방법을 확장 시 사용하는 Annotation.
    - @ContextConfiguration은 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지정.
    - 여러 테스트 클래스에서 같은 AC를 사용시, @ContextConfiguration을 이용해 하나의 AC만 생성.
    - @Autowired는 스프링의 DI에 이용. @Autowired 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾아 주입.
    - @Autowired는 같은 타입의 빈이 두 개 이상 있는 경우, 타입만으로는 어떤 빈을 가져올지 결정할 수 없음.
    - 인터페이스를 이용해 애플리케이션 코드와 테스트의 관계를 느슨하게 연결하는 것이 좋음.
  ### DI와 테스트
    - 정해진 클래스만 쓸거면 꼭 인터페이스 써야함?
      1. SW개발에 절대 바뀌지 않는 것은 없음.
      2. 인터페이스를 이용시 기능추가에 용이.
      3. 테스트를 효율적으로 할 수 있음.
    - 운영DB에서 테스트를 하면 데이터들을 다 날려먹을 가능성 존재, 경우에 따라 코드를 바꾸기는 번거로움 -> 테스트 코드에의한 DI를 이용해 테스트 중 DAO가 사용 할 오브젝트를 바꿈. @DirtiesContext를 이용 시 테스트 메소드에서 AC의 구성이나 상태를 변경한다는 것을 알려줌.
    - @DirtiesContext이용한 테스트 클래스는 AC를 공유해 이용하지 않음.(메소드에서도 이용가능)
    - 테스트에서 이용될 빈을 따로 설정하는 것도 방법 중 하나이다. xml변경후 @ContextConfiguration(locations="###")###부분을 변경.
    - 스프링 컨테이너를 사용하지 않고 테스트를 만듦.
    - invasive기술은 무조건 이용을 강제하는 기술, noninvasive기술은 애플리케이션 로직에 영향을 주지 않고 적용 가능.
## 5. 학습 테스트로 배우는 스프링
  - 남의 코드와 기능에 대한 테스트를 작성하는 것 -> 학습 테스트.
  ### 학습 테스트의 장점
    - 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.
    - 학습 테스트 코드를 개발 중에 참고할 수 있다.
    - 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
    - 테스트 작성에 대한 좋은 훈련이 된다.
    - 새로운 기술을 공부하는 과정이 즐거워진다.
  ### 버그 테스트
    - 테스트의 완성도를 높여준다.
    - 버그 내용을 명확하게 분석하게 해준다.
    - 기술적인 문제를 해결하는데 도움이 된다.
    - 동등분할 : 같은 결과를 내는 값의 범위를 구분해서 각 대표값을 테스트 하는 방법. (T,F,Exception 나오도록)
    - 경계값 분석 : 최대 최소값, 0등에서 에러가 나오니 이런값으로 테스트.
## 2장 정리 후기
- 다시 읽어서 그런지 기억하는데 도움이 될듯.
