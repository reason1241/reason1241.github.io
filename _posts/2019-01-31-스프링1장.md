---
layout: post
title:  "토비 스프링 1장"
date:   2019-01-31 22:00:00
categories: Tech
---
# 1장 오브젝트와 의존관계

- 스프링은 객체지향의 기초와 원칙, 디자인 패턴, 리팩토링, 단위 테스트 등의 지식을 요구한다.

★ 용어정리

- DAO(Data Access Object) : DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하는 오브젝트
- 자바빈(빈) : 두 가지 관례에 따라 만들어진 오브젝트
1. 디폴트 생성자 : 자바빈은 파라미터가 없는 디폴트 생성자가 있어야함.(리플렉션으로 생성되기 때문)
2. 프로퍼티 : setter와 getter로 접근이 가능하다.
- 리팩토링 : 기존 기능에 영향을 주지 않으면서 코드의 내부 구조를 재구성해 개선하는 것. 유지보수, 재사용에 용이.
- 디자인 패턴 : 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션.(클래스 상속, 오브젝트 합성)
- 템플릿 메소드 패턴 : 변하지 않는 기능은 슈퍼클래스에, 자주 변경되며 확장할 기능은 서브클래스에.
- 팩토리 메소드 패턴 : 서브클래스에서 오브젝트 생성 방법과 클래스를 결정.
- 객체지향 설계 원칙(SOLID) : 단일 책임 원칙, 개방 폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존관계 역전 원칙
- 전략 패턴 : context내에서 변경이 필요한 알고리즘을 인터페이스를 통해 외부로 통째로 분리, 구현하는 디자인 패턴. 
- 동일성과 동등성 : 완전히 같은 것은 동일성, 포함한 값이 같은 것은 동등성.
- 싱글톤 패턴 : 어떤 클래스가 애플리케이션 내에서 하나만 존재하도록 강제하는 패턴.
## 1 DAO의 분리
### 관심사의 분리
- 관심이 같은 것끼리 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 따로 떨어져 영향을 주지 않도록 하는 것.
- 변경이 일어날 때 필요한 작업을 최소화.
- 분리, 확장을 고려.
- DAO에서 관심사의 분리를 한다면? -> DB Connection, Query만들기, Resource return.
- 해결을 위해 중복 코드를 메소드로 추출
- 변화가 발생 가능한 부분을 추상메소드(or 오버라이드(훅 메소드))로 만들어 유연성을 부여 가능. 이를 상속받아 이용. 손쉽게 확장 가능. -> 템플릿 메소드 패턴
- 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것(상위 클래스에서 하위클래스가 어떤 인터페이스를 생성할지 결정) -> 팩토리 메소드 패턴
## 2 DAO의 확장
### 클래스의 분리
- 다른 클래스로 분리시킴. new로 호출해서 이용 가능. -> 한 클래스가 다른 클래스에 종속됨. -> 메소드 이름이 달라지면 수정사항이 많아짐, DB커넥션을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으로 알아야함. -> UserDao의 수정이 불가피. -> 원인은 UserDao가 ConnectionMaker에 대해 너무 많이 알고 있는 것.(종속)
### 인터페이스의 도입
- 인터페이스의 도입. -> 클래스 내에서 오브젝트를 할당한다면 의미가 없음 -> UserDao의 클라이언트가 UserDao가 사용할 오브젝트를 주입하게함.
### 관계설정 책임의 분리
- 오브젝트간의 다이나믹 한 관계를 만든다.(클래스간 관계라면 인터페이스가 필요없음, 종속), 다형성
- 클라이언트가 인터페이스로 연결되어 있던 관계를 런타임 오브젝트 관계를 갖는 구조로 만듦.
### 원칙과 패턴
- 개방 폐쇄 원칙(OCP, Open-Closed Principle) : 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 함.
- 객체지향 설계 원칙(SOLID) : 단일 책임 원칙, 개방 폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존관계 역전 원칙
- 높은 응집도와 낮은 결합도 :변화가 일어날 때 한 모듈에서 변화가 크며, 다른 오브젝트 또는 모듈과는 느슨한 형태를 유지해야함.
- 전략 패턴 : context내에서 변경이 필요한 알고리즘을 인터페이스를 통해 외부로 통째로 분리, 구현하는 디자인 패턴. context의 client가 context가 이용할 strategy를 주입하는 것이 일반적.
## 3 제어의 역전(IoC, Inversion of Control)
### 오브젝트 팩토리
- 팩토리 : 오브젝트의 생성 방법을 결정, 이렇게 만들어진 오브젝트를 return하는 클래스.
- 데이터 로직과 기술로직을 담당하는 부분, 애플리케이션을 구성하는 컴포넌트의 구조와 관계를 정의하는 부분을 분리.
### 제어권 이전을 통한 제어관계 역전
- 기존의 프로그램의 흐름은 프로그램이 시작되는 지점에서 다음에 사용할 오브젝트를 결정, 생성하고, 이 오브젝트의 메소드를 호출하며 다음 것을 결정, 호출하는 방식. -> 각 오브젝트가 프로그램 흐름을 결정하고 사용 오브젝트 구성 작업에 참여.
- 제어의 역전은 오브젝트가 자신이 사용할 오브젝트를 스스로 생성, 선택하지 않음.
  - 예)서블릿, 프레임워크(프레임워크가 흐름을 주도하는 중 개발한 클래스가 이용되는 것, 라이브러리는 코드로 애플리케이션 흐름을 직접 제어)
## 4 스프링의 IoC
### 애플리케이션 컨텍스트와 설정 정보
- 빈(bean) : 스프링이 제어권을 가지고 직접 만들과 관계를 부여하는 오브젝트
- 빈 팩토리(Bean Factory) = 애플리케이션 컨텍스트(Application Context) : 빈의 생성과 관계설정 같은 제어를 담당하는 IoC
- BF - 빈을 생성하고 관계를 설정하는 IoC의 기본 기능에 초점, AC - 애플리케이션 전반의 모든 구성요소의 제어 작업을 담당하는 IoC 엔진
- @Configuration : AC가 사용할 설정정보라는 표시, 이용 시에는 AnnotationConfigApplicationContext(빈 팩토리)를 이용
- @Bean : 오브젝트 생성을 담당하는 IoC용 메소드, AnnotationConfigApplicationContext의 getBean(메소드 이름, 클래스)을 이용.
### 애플리케이션 컨텍스트의 동작방식
- 오브젝트 팩토리 = 애플리케이션 컨텍스트 = IoC 컨테이너 = 스프링 컨테이너 = 빈 팩토리
- AC는 생성정보와 연관관걔 정보를 별도의 설정 정보를 통해 얻어 오브젝트 간 관계를 맺어줌. @Configuration이 붙은 설정정보를 이용.
- 장점 : 확장에 용이
  1. 클라이언트가 구체적인 팩토리 클래스를 알 필요가 없다.
  2. AC는 종합 IoC 서비스를 제공
  3. AC는 빈을 검색하는 다양한 방법을 제공
### 스프링의 IoC의 용어 정리
- 빈 : 스프링이 직접 생성과 제어를 담당하며 IoC 방식으로 관리하는 오브젝트
- 빈 팩토리 : 빈의 등록, 생성, 조회 등 기능을 제공하는 스프링의 IoC를 담당하는 핵심 컨테이너. 이를 바로 사용하지 않고 AC를 이용.
- 애플리케이션 컨텍스트 : 빈 팩토리의 확장. 빈 팩토리에 스프링의 부가기능을 제공.
- 설정정보/ 설정 메타정보 : AC 혹은 BF가 IoC를 적용하기 위해 이용하는 메타정보.(@Configuration)
- (IoC)컨테이너 : AC or BF. 여러개의 AC 오브젝트가 모여 애플리케이션을 만들며, 이를 스프링 컨테이너라 함.
- 스프링(프레임워크) : IoC 컨테이너, AC 등을 포함해 스프링이 제공하는 모든 기능을 총칭.
## 5 싱글톤 레지스트리와 오브젝트 스코프
### 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
- AC = 싱글톤 레지스트리
- 싱글톤 패턴 : 어떤 클래스가 애플리케이션 내에서 하나만 존재하도록 강제하는 패턴.
- 싱글톤 구현의 문제점
  1. private 생성자이기에 상속 불가. -> 객체지향 적용 힘듦.
  2. 테스트 힘듦. ex) Mock 오브젝트 대체 힘듦, 오브젝트 주입 힘듦.
  3. 서버환경은 싱글톤을 보장하기 힘듦.
  4. 싱글톤의 사용이 전역 상태를 만들 수 있음.
- 싱글톤 레지스트리 : 스프링 컨테이너가 싱글톤을 생성, 관리, 공급하는 것.
  1. private이 아님.
  2. 테스트가 쉬움. ex) Mock으로 대체 쉬움. 자유롭게 오브젝트 생성 가능(?)
  3. 객체지향 적용, 디자인 패턴 적용에 제약이 없음.
### 싱글톤과 오브젝트의 상태
- 싱글톤은 기본적으로 stateless방식, 이를위해 파라미터, 로컬 변수, 리턴 값등을 이용.
- 초기 설정 후 사용 중 변하지 않는 것만 싱글톤으로 이용하는 것이 좋음.
### 스프링 빈의 스코프
- 빈의 스코프 : 빈이 생성됙, 존재하고, 적용되는 범위.
- 대체적으로 싱글톤 스코프.
- prototype 스코프 : 컨테이너에서 빈을 요청할 때마다 새로운 오브젝트를 만듦.
- request 스코프 : http 요청이 생길때 마다 생성.
- session 스코프 : 웹의 세션과 유사.
## 6 의존관계 주입(DI)
### IoC와 의존관계 주입(Dependency Injection)
### 런타임 의존관계 설정
- 의존관계 : A가 변하면 B에 영향을 미침. "방향성". 역이 성립하지 않음.
- 인터페이스를 이용해 느슨한 의존관계로 설계 시 런타임 시에 사용할 오브젝트가 어떤 클래스의 오브젝트인지 미리 알수 없음.
- 의존 오브젝트 : 런타임 시에 의존관계를 맺는 대상.
- 의존관계 주입 : 클라이언트와 오브젝트를 런타임 시에 연결해주는 작업.
- AC, BF, IoC 컨테이너 등이 런타임 의존관계를 맺어주는 책임을 지님.
### 의존관계 검색(Dependency Lookup)과 주입
- 의존관계 검색 : 스스로 검색을 해서 의존관계를 맺음.
- 직접 빈 팩토리를 선언 후 빈 팩토리에서 메소드를 통해 오브젝트를 호출.(getBean)
- 적어도 한번은 의존관계 검색을 이용해야 함.(최상위에서는 DI를 받을 수 없으므로)
- 검색하는 오브젝트는 사진이 스프링 빈일 필요가 없음.
- 의존관계 주입에서, 컨테이너가 오브젝트에 오브젝트를 주입하려면 주입 당하는 오브젝트를 AC가 생성, 초기화 할 수 있어야함. -> 스프링 빈이어야 함.
### 의존관계 주입 응용
- 기능 구현의 교환 : 필요에 따라 원하는 자원으로 바꾸기 용이
- 부가기능 추가 : 기능 추가가 용이
### 메소드를 이용한 의존관계 주입
- 수정자 메소드를 이용한 주입
- 일반 메소드를 이용한 주입
## 7 XML을 이용한 설정
- 자바코드로 만들기 귀찮은데? -> XML을 이용.
### XML 설정
- @Bean으로는 빈의 이름, 빈의 클래스, 빈의 의존 오브젝트를 알 수 있음. -> xml의 <bean>한번에 가능.
- @Configuration -> <beans>, @Bean methodName() -> <bean id="methodName", return new BeanClass(); -> class="a.b.c...BeanClass">
- 수정자 메소드는 property가 됨. <property> 태그를 사용해 의존 오브젝트 관계를 정의.
- <property name="수정자 메소드" ref="빈 이름"/>
- XML 문서의 구조를 정의하는 방법은 DTD와 스키마가 존재.
### XML을 이용하는 AC
- applicationContext.xml -> AC가 이용하는 설정파일. 클래스 패스 최상단에 둠.
- xml 이용시엔 AnnotationConfigApplicationContext 대신 GenericXmlApplicationContext를 이용, 생성자에 클래스 패스를 넣음.
- xml을 클래스 패스에서 가져올 때는 ClassPathXmlApplicationContext를 이용.
### DataSource 인터페이스로 변환
- DB커넥션 만들 시 DataSource 인터페이스, 구현 클래스를 이용.
  - java 설정 방식
    -빈 메소드 정의 방식
  - xml 설정 방식
    -xml에 잘 추가한다.
### 프로퍼티 값 주입
- 다이나믹한 관계를 만들기 위함이 아닌, 변경 가능한 정보의 설정을 용이하게 하기 위함.
- property 의 value 값을 이용.

## ★추천 책
- 리팩토링(마틴 파울러, 켄트 벡)
- GoF의 디자인 패턴(에릭 감마 외)
- Head First Design Patterns(에릭 프리먼)



## 1장 정리 후기.
- 기억하기는 좋은 것 같긴 하나 시간이 너무 오래 걸린다. 읽는 방법, 정리 방법의 개선이 필요하다.
