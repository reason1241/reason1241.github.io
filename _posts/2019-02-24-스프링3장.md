---
layout: post
title:  "토비 스프링 3장"
date:   2019-02-24 17:00:00
categories: Tech
---
# 3장 템플릿



  - 템플릿이란 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜 효과적으로 활용할 수 있도록 하는 방법.
## 1. 다시보는 초난감 DAO
  - DB 커넥션 등 제한적 리소스를 공유해 사용하는 서버선 반드시 예외처리를 지켜야 함. 반드시 리소스를 반환해야 하기 때문.
  - DB 커넥션 등은 일반적으로는 풀을 이용해 관리. 이를 close()를 통해 풀에 넣어 후에 재사용 할 수 있음.
  - try/catch/finally를 이용해 connection, prepared statement, result set을 close 해야함.
  
## 2. 변하는 것과 변하지 않는 것
  - try/catch/finally 가 쌓임 ->  복잡 -> 오류 가능성 증가 -> 분리의 필요성.
  - 변하지 않는 부분(try/catch/finally)를 변하는 부분과 분리 -> 메소드 추출.(변하는 부분을) -> 재사용이 안됨 -> 이상..
  - 템플릿 메소드 패턴을 적용(추상 메소드, 상속 이용) -> 변하지 않는 부분을 super class, 변하는 부분을 sub class에서 override.
  - DAO 로직마다 상속으로 새 클래스를 만들어야 함, 확장구조가 클래스 설계 시점에 고정되는 문제점 -> 유연성 저하
  - 전략 패턴 적용(인터페이스를 이용) -> Context 내에 Strategy 인터페이스로 외부 전략 클래스에 위임.
  - DI를 통해 이를 실현 가능.
  - 마이크로 DI : 클라이언트가 오브젝트 팩토리의 책임을 지거나 클라이언트와 전략이 결합 될 수 있음. 혹은 클라이언트와 DI관계에 있는 두 개의 오브젝트가 모두 하나의 클래스 안에 담길 수 있음. -> IoC 컨테이너 없이 코드 내에서 DI를 적용한 것을 마이크로 DI라 함.(수동 DI)
  
## 3. JDBC 전략 패턴의 최적화
  - DAO 메소드 마다 새로운 StatementStrategy 구현 클래스를 만들어야 한다? StatementStrategt에 전달할 정보가 있으면 생성자와 이를 저장할 변수를 만들어야한다?
  - 클래스 파일이 많아지는 것은 로컬 클래스로 해결. -> 로컬 클래스는 생성자 없이 내부정보 접근 가능.(but final로 선언 필요)
  - nested class는 static class와 inner class로 구분. inner class는 scope에 따라 member inner class(오브젝트 레벨), local class,(메소드 레벨) anonymous inner class로 구분.
  - anonymous inner class는 클래스 재사용할 필요 없을 때 이용, 이름까지 지울 수 있어 더 간단하게 이용 가능.
  
## 4. 컨텍스트와 DI
  - 스프링 DI는 객체의 생성과 관계설정에 대한 제어권한을 오브젝트에서 제거하고 외부로 위임했다는 IoC라는 개념을 포괄.
  - JdbcContext를 DI구조로 만들어야 하는 이유?
    1. JdbcContext가 싱글톤 빈이 되기 때문.
    2. JdbcContext가 DI를 통해 다른 빈에 의존하고 있기 때문. DI를 위해서는 양쪽 오브젝트 모두 스프링 빈이 되어야 함.
  - 인터페이스가 없는 DI -> 강결합, 강한 응집도 -> 꼭 인터페이스를 통한 DI를 해야하는 것은 아님.
  - 수동 DI -> 싱글톤 포기. but 계속 새로 생성하라는 것은 아님.
  - JdbcContext가 스프링 빈 아님 -> DI 불가 -> 상위에서 DI.
  - 인터페이스 없이 DI하는 법
    1. 스프링 DI를 이용하기 위해 빈으로 등록해 사용하는 방법
      - 의존관계가 설정파일에 명확히 드러남.
      - 구체적 클래스와의 관계가 설정에 직접 노출.
    2. 수동 DI
      - 외부에 전략 감출 수 있음.
      - 싱글톤 불가, DI를 위한 부가적 코드 필요.
      
## 5. 템플릿과 콜백
  - 템플릿/콜백 패턴 : 전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식.
  - 콜백 : 실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트.(functional object)
    ### 템플릿 / 콜백의 동작 원리
      - 보통 단일 메소드 인터페이스를 사용.(템플릿의 작업 흐름 중 특정 기능을 위해 한 번 호출되는 경우가 일반적)
      - 메소드 레벨의 DI(메소드 단위로 사용할 오브젝트를 새롭게 전달받음)
      - 콜백 오브젝트가 내부 클래스로서 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조. 강결합.
    ### 편리한 콜백의 재활용
      - 이 익명 내부 클래스 조차 메소드로 묶어서 따로 뺌.(String 외에 변하는 것이 없으므로)
      - 성격이 다른 코드는 분리하는 것이 좋으나, 긴밀하게 연관되어 있는 경우는 한군데 모으는 것이 유리.
    ### 템플릿 콜백의 응용
      - try/catch/finally가 대표적으로 이용할 수 있는 예.
      - 변하는 부분과 변하지 않는 부분의 경계를 찾아내는 것이 중요.
      - 제네릭스를 이용 할 수도...
      
## 6. 스프링의 JDBCTEMPLATE
  - JdbcTemplate쓰면 다 알아서 해준다. 위의 일들은 공부 할때나 쓰도록.
  - update, queryForInt, queryForObject, query 등의 다양한 기능을 콜백과 결합해 이용 가능.
  - 어떻게 동작하는지 직접 확인해 보는 것은 좋은 일이다.
  - 코드정리, RowMapper 중복 제거 등.
  - 더 낮은 결합도를 유지하고 싶으면 JdbcTemplate를 독립적인 빈으로 등록 후 JdbcOperation 인터페이스를 통해 DI받아 사용해도 됨.
  - 개선 가능 사항?
    1. userMapper를 프로퍼티로 만드는 것은 어떨까?
    2. SQL 문장을 외부 리소스에서 담아 읽어와 사용.
## 3장 정리 후기
- 화이팅
